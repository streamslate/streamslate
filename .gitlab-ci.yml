# StreamSlate GitLab CI/CD Configuration
#
# Required CI/CD Variables (Settings > CI/CD > Variables):
# ─────────────────────────────────────────────────────────
#
# For macOS Code Signing (build:macos job):
#   APPLE_CERTIFICATE          - Base64-encoded .p12 certificate file (or File type variable)
#   APPLE_CERTIFICATE_PASSWORD - Password for the .p12 certificate
#
# For macOS Notarization (API Key method - recommended):
#   APPLE_API_ISSUER           - App Store Connect API Issuer ID
#   APPLE_API_KEY              - App Store Connect API Key ID
#   APPLE_API_KEY_BASE64       - Base64-encoded .p8 API key file
#   APPLE_TEAM_ID              - Apple Developer Team ID
#
# For Container Registry (docker:build job):
#   Uses central BuildKit server + Harbor registry (registry.harbor.lan)
#   No additional CI variables needed - BuildKit server has push credentials
#
# Runner Requirements:
#   - Linux runner for test:linux:rust and test:linux:e2e:* jobs (any GitLab runner)
#   - macOS runner with tag 'macos' for build:macos job
#   - K3s runner with Harbor image pull access for docker:build job
#

stages:
  - lint
  - test
  - build
  - deploy

variables:
  CARGO_TERM_COLOR: always
  # Keep Cargo downloads inside the repo workspace so GitLab cache paths are
  # relative and we avoid caching huge build outputs like src-tauri/target/.
  CARGO_HOME: "$CI_PROJECT_DIR/.cargo"
  # Use cached dependencies
  npm_config_cache: "$CI_PROJECT_DIR/.npm"
  # Increase npm timeout and retries for flaky K8s runner network
  npm_config_fetch_retries: "5"
  npm_config_fetch_retry_mintimeout: "20000"
  npm_config_fetch_timeout: "120000"
  RUST_BACKTRACE: 1

.cache_npm: &cache_npm
  key:
    prefix: npm-v3
    files:
      - package-lock.json
  paths:
    - .npm/

.cache_cargo: &cache_cargo
  key:
    prefix: cargo-v3
    files:
      - src-tauri/Cargo.lock
  paths:
    - .cargo/registry/
    - .cargo/git/

default:
  cache:
    - <<: *cache_npm
      policy: pull-push
    - <<: *cache_cargo
      policy: pull-push

.linux: &linux
  image: rust:latest
  before_script:
    - apt-get update
    - apt-get install -y ca-certificates curl
    - update-ca-certificates --fresh
    - export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
    - export CURL_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
    - export RUSTUP_USE_CURL=1
    - apt-get install -y npm nodejs
    - grep -v '^#' requirements/ubuntu-build.txt | grep -v '^$' | xargs apt-get install -y
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/javascriptcoregtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/javascriptcoregtk-4.0.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/libsoup-3.0.pc /usr/lib/x86_64-linux-gnu/pkgconfig/libsoup-2.4.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libwebkit2gtk-4.1.so /usr/lib/x86_64-linux-gnu/libwebkit2gtk-4.0.so || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libjavascriptcoregtk-4.1.so /usr/lib/x86_64-linux-gnu/libjavascriptcoregtk-4.0.so || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libsoup-3.0.so /usr/lib/x86_64-linux-gnu/libsoup-2.4.so || true
    - rustup component add rustfmt clippy
    - npm ci --prefer-offline --no-audit

.linux-rust: &linux-rust
  image: rust:latest
  before_script:
    - apt-get update
    - apt-get install -y ca-certificates curl
    - update-ca-certificates --fresh
    - export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
    - export CURL_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
    - export RUSTUP_USE_CURL=1
    - grep -v '^#' requirements/ubuntu-build.txt | grep -v '^$' | xargs apt-get install -y
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/javascriptcoregtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/javascriptcoregtk-4.0.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/libsoup-3.0.pc /usr/lib/x86_64-linux-gnu/pkgconfig/libsoup-2.4.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libwebkit2gtk-4.1.so /usr/lib/x86_64-linux-gnu/libwebkit2gtk-4.0.so || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libjavascriptcoregtk-4.1.so /usr/lib/x86_64-linux-gnu/libjavascriptcoregtk-4.0.so || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libsoup-3.0.so /usr/lib/x86_64-linux-gnu/libsoup-2.4.so || true
    - rustup component add rustfmt clippy

lint:linux:
  stage: lint
  <<: *linux
  retry:
    max: 2
    when: script_failure
  script:
    # TypeScript, Format, Lint
    - npx tsc --noEmit
    - npm run format:check
    - npm run lint
    # Rust format check + clippy (run together since cd persists between script lines)
    - cd src-tauri
    - cargo fmt --all -- --check || echo "Skipping cargo fmt check"
    - cargo clippy --all-targets -- -D warnings

test:linux:rust:
  stage: test
  <<: *linux-rust
  # Start immediately (don't wait for lint stage) for faster test feedback.
  needs: []
  cache:
    - <<: *cache_cargo
      policy: pull
  script:
    # Rust tests
    - cd src-tauri && cargo test

.test:linux:e2e:
  stage: test
  <<: *linux
  # Start immediately (don't wait for lint stage) for faster test feedback.
  needs: []
  cache:
    - <<: *cache_npm
      policy: pull
  script:
    # Install E2E-only runtime deps (skip cross-compiler toolchains)
    - grep -v '^#' requirements/ubuntu-dev.txt | grep -v '^$' | grep -v '^-r' | grep -v 'gcc-arm-linux-gnueabihf' | grep -v 'gcc-aarch64-linux-gnu' | xargs apt-get install -y
    # Start xvfb for headless browser testing (Cypress requires a display)
    - Xvfb :99 -screen 0 1920x1080x24 &
    - export DISPLAY=:99
    # Start dev server in background
    - npm run dev &
    - export DEV_PID=$!
    # Wait for server to be ready (poll instead of fixed sleep)
    - |
      DEV_SERVER_READY=false
      for i in $(seq 1 30); do
        if curl -s http://localhost:1420 > /dev/null; then
          DEV_SERVER_READY=true
          break
        fi
        echo "Waiting for dev server... ($i/30)"
        sleep 2
      done
    # Run Cypress E2E tests only if dev server started
    - |
      if [ "$DEV_SERVER_READY" = "true" ]; then
        npx cypress run --spec "${CYPRESS_SPECS}"
      else
        echo "❌ Dev server did not start - failing E2E test job"
        exit 1
      fi
    - kill $DEV_PID || true

test:linux:e2e:core:
  extends: .test:linux:e2e
  variables:
    CYPRESS_SPECS: "cypress/e2e/annotations-edit.cy.ts,cypress/e2e/app.cy.ts,cypress/e2e/pdf-viewer.cy.ts,cypress/e2e/settings.cy.ts"

test:linux:e2e:integration:
  extends: .test:linux:e2e
  variables:
    CYPRESS_SPECS: "cypress/e2e/integration-websocket.cy.ts,cypress/e2e/sidebar.cy.ts,cypress/e2e/workflow.cy.ts"

build:macos:
  stage: build
  tags:
    - macos
  needs: []
  script:
    - npm ci
    - ./scripts/import-certificate.sh
    - set -a && source build.env && set +a
    - echo "Signing with identity $APPLE_SIGNING_IDENTITY"
    - if [ -n "$APPLE_API_KEY_BASE64" ]; then API_KEY_PATH="$PWD/AuthKey_${APPLE_API_KEY}.p8"; echo "$APPLE_API_KEY_BASE64" | base64 --decode > "$API_KEY_PATH"; export APPLE_API_KEY_PATH="$API_KEY_PATH"; echo "APPLE_API_KEY_PATH=$API_KEY_PATH" >> build.env; echo "Notarization API key ready"; else echo "Warning APPLE_API_KEY_BASE64 not set, notarization will be skipped"; fi
    - npm run tauri:build
  after_script:
    - if [ -f build.env ]; then source build.env; fi
    - if [ -n "$KEYCHAIN_PATH" ]; then security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true; fi
    - if [ -n "$ORIGINAL_KEYCHAINS" ]; then security list-keychains -d user -s $ORIGINAL_KEYCHAINS; fi
    - if [ -n "$APPLE_API_KEY_PATH" ]; then rm -f "$APPLE_API_KEY_PATH"; fi
    - rm -f build.env
  artifacts:
    paths:
      - src-tauri/target/release/bundle/dmg/*.dmg
      - src-tauri/target/release/bundle/macos/*.app
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

docker:build:
  stage: deploy
  # Run as soon as tests pass — don't wait for macOS build stage
  needs:
    [
      "lint:linux",
      "test:linux:rust",
      "test:linux:e2e:core",
      "test:linux:e2e:integration",
    ]
  cache: []
  # BuildKit client image (cached in Harbor) - no DinD needed.
  # Override entrypoint: the default is 'buildkitd' (the daemon), but we
  # only need the 'buildctl' CLI to talk to the remote BuildKit server.
  image:
    name: registry.harbor.lan/dockerhub-cache/moby/buildkit:v0.12.5
    entrypoint: [""]
  variables:
    # Disable DinD wait in runner pre-build script
    DOCKER_HOST: ""
    # Central BuildKit server has Harbor CA trust + push credentials
    BUILDKIT_HOST: tcp://buildkitd-central.ci-build.svc.cluster.local:1234
    HARBOR_IMAGE: registry.harbor.lan/streamslate/streamslate
  script:
    - |
      NAMES="${HARBOR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        NAMES="${NAMES},${HARBOR_IMAGE}:latest"
      fi
      #
      # NOTE: Harbor cache export has intermittently failed with a 404 when
      # writing the buildcache manifest. Since this cache is an optimization,
      # retry the build without registry cache flags if the failure matches
      # that specific condition.
      #
      # This keeps image publishing reliable while preserving caching when it
      # works.
      set -eu
      CACHE_REF="${HARBOR_IMAGE}:buildcache"

      run_build() {
        buildctl build \
          --frontend dockerfile.v0 \
          --local context=. \
          --local dockerfile=. \
          --output "type=image,\"name=${NAMES}\",push=true" \
          "$@"
      }

      run_build_with_log() {
        rm -f buildctl.pipe buildctl.log
        mkfifo buildctl.pipe
        tee buildctl.log < buildctl.pipe &
        TEE_PID=$!

        set +e
        run_build "$@" > buildctl.pipe 2>&1
        RC=$?
        set -e

        wait "$TEE_PID" || true
        rm -f buildctl.pipe
        return "$RC"
      }

      if ! run_build_with_log \
          --export-cache "type=registry,ref=${CACHE_REF},mode=max" \
          --import-cache "type=registry,ref=${CACHE_REF}"; then
        if grep -Eq "error writing manifest blob|/manifests/buildcache|buildcache" buildctl.log; then
          echo "Registry cache export failed; retrying build without registry cache flags..."
          run_build_with_log
        else
          echo "buildctl failed (not a known registry-cache export failure); failing job."
          exit 1
        fi
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
