# StreamSlate GitLab CI/CD Configuration
#
# Required CI/CD Variables (Settings > CI/CD > Variables):
# ─────────────────────────────────────────────────────────
#
# For macOS Code Signing (build:macos job):
#   APPLE_CERTIFICATE          - Base64-encoded .p12 certificate file (or File type variable)
#   APPLE_CERTIFICATE_PASSWORD - Password for the .p12 certificate
#
# For macOS Notarization (API Key method - recommended):
#   APPLE_API_ISSUER           - App Store Connect API Issuer ID
#   APPLE_API_KEY              - App Store Connect API Key ID
#   APPLE_API_KEY_BASE64       - Base64-encoded .p8 API key file
#   APPLE_TEAM_ID              - Apple Developer Team ID
#
# For Container Registry (docker:build job):
#   Uses built-in GitLab CI variables:
#   - CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD, CI_REGISTRY_IMAGE
#   (Automatically available when Container Registry is enabled)
#
# Runner Requirements:
#   - Linux runner for test:linux job (any GitLab runner)
#   - macOS runner with tag 'macos' for build:macos job
#   - Docker-in-Docker for docker:build job
#

stages:
  - lint
  - test
  - build
  - deploy

variables:
  CARGO_TERM_COLOR: always
  # Use cached dependencies
  npm_config_cache: "$CI_PROJECT_DIR/.npm"
  RUST_BACKTRACE: 1

default:
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .npm/
      - src-tauri/target/
      - ~/.cargo/registry/
      - ~/.cargo/git/

.linux: &linux
  image: rust:latest
  before_script:
    - apt-get update
    - apt-get install -y ca-certificates curl
    - update-ca-certificates --fresh
    - export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
    - export CURL_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
    - export RUSTUP_USE_CURL=1
    - apt-get install -y npm nodejs
    - xargs -a requirements/ubuntu-build.txt apt-get install -y
    - grep -v '^#' requirements/ubuntu-dev.txt | grep -v '^$' | grep -v '^-r' | xargs apt-get install -y
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/javascriptcoregtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/javascriptcoregtk-4.0.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/libsoup-3.0.pc /usr/lib/x86_64-linux-gnu/pkgconfig/libsoup-2.4.pc || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libwebkit2gtk-4.1.so /usr/lib/x86_64-linux-gnu/libwebkit2gtk-4.0.so || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libjavascriptcoregtk-4.1.so /usr/lib/x86_64-linux-gnu/libjavascriptcoregtk-4.0.so || true
    - ln -sf /usr/lib/x86_64-linux-gnu/libsoup-3.0.so /usr/lib/x86_64-linux-gnu/libsoup-2.4.so || true
    - rustup component add rustfmt clippy
    - npm ci

lint:linux:
  stage: lint
  <<: *linux
  script:
    # TypeScript, Format, Lint
    - npx tsc --noEmit
    - npm run format:check
    - npm run lint
    # Rust format check (skip gracefully if rustfmt wasn't installed)
    - cd src-tauri && (cargo fmt --all -- --check || echo "Skipping cargo fmt check")
    # Clippy (default features only - ndi feature requires proprietary SDK)
    - cargo clippy --all-targets -- -D warnings

test:linux:
  stage: test
  <<: *linux
  script:
    # Rust tests (primary validation)
    - cd src-tauri && cargo test
    - cd ..
    # Start xvfb for headless browser testing (Cypress requires a display)
    - Xvfb :99 -screen 0 1920x1080x24 &
    - export DISPLAY=:99
    # Start dev server in background
    - npm run dev &
    - export DEV_PID=$!
    # Wait for server to be ready (poll instead of fixed sleep)
    - |
      DEV_SERVER_READY=false
      for i in $(seq 1 30); do
        if curl -s http://localhost:1420 > /dev/null; then
          DEV_SERVER_READY=true
          break
        fi
        echo "Waiting for dev server... ($i/30)"
        sleep 2
      done
    # Run Cypress E2E tests only if dev server started
    - |
      if [ "$DEV_SERVER_READY" = "true" ]; then
        npm run test:headless
      else
        echo "⚠️ Dev server did not start - skipping Cypress E2E tests"
        echo "Rust tests passed, E2E tests will run on macOS build"
      fi
    - kill $DEV_PID || true

build:macos:
  stage: build
  tags:
    - macos
  script:
    - npm ci
    - ./scripts/import-certificate.sh
    # Export build.env vars so child processes (tauri build) can see them
    - set -a && source build.env && set +a
    - echo "Signing with identity: $APPLE_SIGNING_IDENTITY"
    # Setup API key for notarization (if configured)
    - |
      if [ -n "$APPLE_API_KEY_BASE64" ]; then
        API_KEY_PATH="$PWD/AuthKey_${APPLE_API_KEY}.p8"
        echo "$APPLE_API_KEY_BASE64" | base64 --decode > "$API_KEY_PATH"
        export APPLE_API_KEY_PATH="$API_KEY_PATH"
        echo "APPLE_API_KEY_PATH=$API_KEY_PATH" >> build.env
        echo "Notarization API key written to: $API_KEY_PATH"
      else
        echo "Warning: APPLE_API_KEY_BASE64 not set, notarization will be skipped"
      fi
    - npm run tauri:build
  after_script:
    # Restore original keychain search list and clean up
    - |
      if [ -f build.env ]; then
        source build.env
        if [ -n "$KEYCHAIN_PATH" ]; then
          security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
        fi
        if [ -n "$ORIGINAL_KEYCHAINS" ]; then
          security list-keychains -d user -s $ORIGINAL_KEYCHAINS
        fi
        if [ -n "$APPLE_API_KEY_PATH" ]; then
          rm -f "$APPLE_API_KEY_PATH"
        fi
        rm -f build.env
      else
        security delete-keychain app-signing.keychain-db 2>/dev/null || true
      fi
  artifacts:
    paths:
      - src-tauri/target/release/bundle/dmg/*.dmg
      - src-tauri/target/release/bundle/macos/*.app
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

docker:build:
  stage: deploy
  image: docker:24.0.7
  services:
    - docker:24.0.7-dind
  variables:
    DOCKER_DRIVER: overlay2
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
        docker push $CI_REGISTRY_IMAGE:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
